/*
  Support function for Floyd-Steinberg dithering of an 8bit grey-scale BMP image
  on a Monochrome display:
  https://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering
  Bitmap format:
  https://en.wikipedia.org/wiki/BMP_file_format

  Example for https://github.com/Bodmer/TFT_eSPI

  The MIT License (MIT)
  Copyright (c) 2015 by Bodmer
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYBR_DATUM HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
  Note: drawFSBmp() is a simplified function and does not handle all possible
  BMP file header variants. It works OK with 8 bit per pixel grey-scale images
  generated by MS Paint and IrfanView.
*/

// https://github.com/Bodmer/TFT_eSPI

//====================================================================================
// Draw an 8 bit grey-scale bitmap (*.BMP) on a Monochrome display using dithering
//====================================================================================
// Uses RAM for buffers (3 * width + 4) ( 532 bytes for 176 pixels)

//   Image must be stored in ESP8266 or ESP32 SPIFFS

//    Quantisation error distribution for pixel X
//     (This is for bottum up drawing of the BMP)
//          |-------|-------|-------|
//          | +3/16 | +5/16 | +1/16 |
//          |-------|-------|-------|
//          |       |   X   | +7/16 |
//          |-------|-------|-------|
//
#include "image_funcs.h"
#include "img_converters.h"
#include "platform.h"


//static volatile int CurrentLine = 0;
//uint8_t LineBuffer[CAMERA_IMAGE_WIDTH + 40];
//int LineCount = 0;


bool fmt2binary(const uint8_t *src_buf, size_t src_len, uint16_t width, uint16_t height, pixformat_t format,  uint8_t * ImageBuffer)//const char *filename, int16_t x, int16_t y) {
  {

      int pix_count = 0;
      //Centre crop extents
      int cropLx=(CAMERA_IMAGE_WIDTH-width)/2;
      int cropRx=cropLx+width;
      int cropBy=(CAMERA_IMAGE_HEIGHT-height)/2;
      int cropTy=cropBy+height;

      if(format == PIXFORMAT_JPEG) {//need to handle this
          return false;
      } else if(format == PIXFORMAT_RGB888) {
        int i;
        uint8_t rb, gb, bb;
        pix_count = src_len;
        for(i=0; i<pix_count; i++) {
            rb = *src_buf++;
            gb = *src_buf++;
            bb = *src_buf++;
            *ImageBuffer++ = 0.1111111* ((gb + (gb<<1) +rb) <<1)+bb ; //convert to greyscale
        }
      } else if(format == PIXFORMAT_RGB565) {
            return false;
      } else if(format == PIXFORMAT_GRAYSCALE) {
          memcpy(ImageBuffer, src_buf, src_len);
      } else if(format == PIXFORMAT_YUV422) {
          return false;
      }


  //uint16_t posx, posy;
  uint16_t posx_crop=0;
  uint16_t posy_crop=0;

  uint16_t row;

      printf("dithering\n");

      // Create an zero an 8 bit pixel line buffer
      uint8_t* lineBuffer = ( uint8_t*) calloc(CAMERA_IMAGE_WIDTH    , sizeof(uint8_t));

      // Create a 16 bit signed line buffer for the quantisation error
      // Diffusion spreads to x-1 and x+1 so w + 2 avoids a bounds check
      int16_t* qerrBuffer = ( int16_t*) calloc((CAMERA_IMAGE_WIDTH + 2)<<1, sizeof(uint8_t));

      // Draw row by row from bottom up
      for (row = 0; row < CAMERA_IMAGE_HEIGHT; row++) {
        //printf("%d\n", row);

        // Read a row of pixels
        //bmpFS.read(lineBuffer, w);
        memcpy(lineBuffer, ImageBuffer+CAMERA_IMAGE_WIDTH*row, CAMERA_IMAGE_WIDTH*sizeof(uint8_t));

        // Prep variables
        uint16_t dx = 0;
        uint8_t* bptr = lineBuffer;
        int16_t* qptr = qerrBuffer + 1; // + 1 because diffusion spreads to x-1

        // Lookup color, add quantisation error, clip and clear error buffer
        while(dx < CAMERA_IMAGE_WIDTH)
        {
          int16_t depixel =  (uint8_t)*bptr + *qptr;
          if (depixel >255) depixel = 255;   // Clip pixel to 0-255
          else if (depixel < 0) depixel = 0;
          *bptr++ = (uint8_t) depixel;       // Save new value, inc pointer
          *qptr++ = 0;                       // Zero error, inc pointer
          dx++;                              // Next pixel
        }

        dx = 0;                // Reset varaibles to start of line
        bptr = lineBuffer;
        qptr = qerrBuffer + 1;
        int32_t qerr = 0;
        int32_t qerr16 = 0;

        // Push the pixel row to screen
        //printf("Putting line to buffer\n");
        while(dx < CAMERA_IMAGE_WIDTH)
        {
           // Add 7/16 of error (error = 0 on first entry)
          int16_t pixel = *bptr + (qerr>>1) - qerr16;


          // Do not clip here so quantisation error accumulates correctly?
          // Draw pixel (black or white) and determine new error
          if (pixel < 128) {//128
            qerr = pixel;
            if ((row>=cropBy && row<cropTy) && (dx>=cropLx && dx<cropRx)){
              ImageBuffer[(posy_crop * width + posx_crop)] = 0;
              //printf("%d\n", (posy_crop * width + posx_crop));
            }
          }
             // frame.drawPixel(x + dx, y, INK);  }

          else{
            qerr = pixel - 255;
            if ((row>=cropBy && row<cropTy) && (dx>=cropLx && dx<cropRx)){
            ImageBuffer[(posy_crop * width + posx_crop)] = 255;
            //printf("%d\n", (posy_crop * width + posx_crop));
            }
          }

          // Diffuse into error buffer for next pixel line
          qerr16 = qerr>>4;                  //     1/16 of error
          *(qptr - 1) += (qerr>>2) - qerr16; // Add 3/16 of error
          *(qptr    ) += (qerr>>2) + qerr16; // Add 5/16 of error
          *(qptr + 1) +=  qerr16;            // Add 1/16 of error

          bptr++; // Move along pixel and error buffers
          qptr++;
          dx++;    // Move coordinate along
          if ((cropBy<=row && row<cropTy) && (cropLx<=dx && dx<cropRx)){
            //printf("%d\n", posx_crop);
            posx_crop+=1;
          }
        }
        //y--;
        posx_crop=0;
        if ((cropBy<=row && row<cropTy)){
          //printf("%d\n", posy_crop);
          posy_crop+=1;
        }

      }
    free(lineBuffer);
    free(qerrBuffer);
return true;
}
